version "4.1.3"

#include "zscript/TiltPlusPlus.zc"
#include "zscript/TiltPlusPlusMenu.zc"
#include "zscript/DeathFader.zc"
#include "zscript/PlayerPawn.zc"
#include "zscript/ZMoveMenu.ZMV"
#include "zscript/PBHitbox.zc"
#include "zscript/Monsters/PBMonster.zc"
#include "zscript/Monsters/ZombieMen/ZombieMan.zc"
#include "zscript/NashGore/NashGoreCommon.zc"
#include "zscript/NashGore/NashGoreStatics.zc"
#include "zscript/NashGore/NashGoreHandler.zc"
#include "zscript/NashGore/NashGoreBlood.zc"
#include "zscript/NashGore/NashGoreBloodPlane.zc"
#include "zscript/NashGore/NashGoreGibs.zc"
#include "zscript/NashGore/NashGoreCrushedGibs.zc"
#include "zscript/NashGore/NashGoreSquishyGibs.zc"
#include "zscript/NashGore/NashGoreIceChunk.zc"
#include "zscript/NashGore/NashGoreLiquidBlood.zc"
#include "zscript/NashGore/NashGoreWallBlood.zc"
#include "zscript/NashGore/NashGoreActor.zc"
#include "zscript/NashGore/NashGoreMenu.zc"
#include "zscript/NashGore/PBBlood.zc"
#include "zscript/NashGore/PBGore.zc"


// global constants
const STAT_NashGore_Gore = Thinker.STAT_USER + 1;

const C_TID	= 1000;	//Default camera tid
const  MAX_R	= 56+32;	//Maximum radius (or distance from the player)
const  ADJUST_R = 8;	//Amount to adjust the camera by
const  VIEW_HEIGHT = 61.0;	//The approximate hight of the player's view
class PB_PDAUi_Object
{
	TextureID DialogPicture;
	Vector2 ImagePos,ImageSize,InitialImagePos;
	bool ExitButtonTrue;
	bool BackButtonTrue;
	int descClipX,descClipY,descClipW,descClipH;
	bool MonsterMenuOnly;
	bool WeaponMenuOnly;
	bool NonMainMenuOnly;
	//Color ColorOverlay;
	int fontcolor;
	int objecttype;
	int entrynumber;
	double globalAlphaValue;
	string toDraw;
	font usefont;
	bool notdrawn;
	bool objectHeldDown;
	bool unmovable;
	bool dontdraw;
	bool MouseOvered;
	bool Clicked;
	bool UnSelectable;
	virtual string GetString()
	{
		Switch(objecttype)
		{
			case 0:
			Default:
				return "Exit";
				break;
			case 1:
				return "Monsters";
				break;
			case 2:
				return "Weapons";
				break;
		}
		return "Exit";
	}
	virtual bool ExitButton()
	{
		return ExitButtonTrue;
	}
	virtual void UiFunction()
	{
		if (!toDraw)
		{
			toDraw = GetString();
		}
	}
	void InitializeTexturedUiObject(TextureID tex)
	{
		let xy = TexMan.GetScaledSize(Tex);
		ImageSize = xy;
		DialogPicture = tex;
	}
	void InitializeUiObject(font touse = "SmallFont")
	{
		let dialog = self;
		dialog.usefont = touse;
		//dialog.colorOverlay = "White";
		dialog.fontcolor = Font.CR_UNTRANSLATED;
		dialog.ImageSize.X = usefont.StringWidth(dialog.toDraw) * CleanXFac;
		dialog.ImageSize.Y = usefont.GetHeight() * CleanYFac;
	}
}
class PB_EventHandler : EventHandler
{
	int MouseX,MouseY,DeltaMouseX,DeltaMouseY;
	uint HeldDownTics;
	int PDAMode;
	ui Vector2 UpArrowPos,DownArrowPos;
	bool ClearArrays;
	bool NonMainMenu;
	bool MonsterMenuOpened,MonsterMenuOnly;
	bool WeaponMenuOpened,WeaponMenuOnly;
	bool MouseClicked,MousePositionSet,MouseHeldDown;
	Array<String> PDAMonsterStrings;
	Array<String> PDAWeaponStrings;
	Array<String> PBWeapons;
	transient ui Array<String> PDAWeaponHeaders;
	transient ui Array<String> PDAWeaponTexts;
	transient ui Array<Double> PDAWeaponTextVSize,PDAWeaponTextHSize;
	transient ui Array<PB_PDAUi_Object> UiObjects;
	transient ui PB_PDAUi_Object descriptiondialog;
	override void WorldThingDied(WorldEvent e)
	{
		if (e.thing && e.thing.target
		&& e.thing.target.player
		&& e.thing.bCOUNTKILL
		&& e.thing.bISMONSTER)
		{
			//e.thing.target.player.mo.A_SetBlend("RoyalBlue",0.1,17);
		}
	}
	override void UiTick()
	{
		for (int i = 0;i < uiObjects.Size();i++)
		{
			if (MouseX >= uiObjects[i].ImagePos.x
				&& MouseX <= (uiObjects[i].ImageSize.x + uiObjects[i].ImagePos.x)
				&& MouseY >= uiObjects[i].ImagePos.y
				&& MouseY <= (uiObjects[i].ImagePos.y + uiObjects[i].ImageSize.y)
				&& (!uiObjects[i].UnSelectable == true) && !uiObjects[i].notdrawn)
			{	
				if (MouseClicked == true && MouseHeldDown != true)
				{
					if (uiObjects[i].ExitButton() == true)
					{
						SendNetworkEvent("exitPDA");
						descriptiondialog.todraw = "Select a entry to \nview its description";
						descriptiondialog.ImagePos = descriptiondialog.InitialImagePos;
					}
					else if (uiObjects[i].objecttype == 1) SendNetworkEvent("OpenMonsterMenu");
					else if (uiObjects[i].objecttype == 2) SendNetworkEvent("OpenWeaponMenu");
					else if (uiObjects[i].objecttype == 3) 
					{
						for (int counter = 0; counter < PDAWeaponHeaders.Size(); ++counter)
						{
							//Console.Printf(PDAWeaponHeaders[counter]);
							if (uiObjects[i].entrynumber == counter)
							{
								descriptiondialog.todraw = PDAWeaponTexts[counter];
							}
						}
					}
					else if (uiObjects[i].BackButtonTrue)
					{
						SendNetworkEvent("closemonstermenu");
						descriptiondialog.todraw = "Select a entry to \nview its description";
						descriptiondialog.ImagePos = descriptiondialog.InitialImagePos;
					}
					else if (MouseHeldDown != true)
					{
						uiObjects[i].UiFunction();
						uiObjects[i].Clicked = true;
						//SendNetworkEvent("releasemouse");
					}
					//else SendNetworkEvent("ReleaseMouse");
				}
				if (uiObjects[i].usefont != NULL)
				{
					if (MouseHeldDown == true)
					{
						uiObjects[i].fontcolor = Font.CR_CYAN;
						if (uiObjects[i].objecttype == 4) DescriptionDialog.ImagePos.y -= -5;
						else if (uiObjects[i].objecttype == 5) DescriptionDialog.ImagePos.y += -5;
					}
					else
					{
						uiObjects[i].fontcolor = Font.CR_RED;
					}
				}
				if (!uiObjects[i].MouseOvered)
				{
					uiObjects[i].MouseOvered = true;
					S_Sound("PDAMOUSEOVER",CHAN_AUTO);
				}
			}
			else 
			{
				uiObjects[i].MouseOvered = false;
				uiObjects[i].fontcolor = Font.CR_UNTRANSLATED;
				//SendNetworkEvent("releasemouse");
				//self.MouseHeldDown = false;
			}
			
		}
	}
	override void PlayerEntered(PlayerEvent e)
	{
		players[e.Playernumber].mo.A_SetBlend("black",1.0,35);
	}
	override void WorldTick()
	{
		if (MouseClicked == false)
		{
			MouseHeldDown = false;
		}
	}
	override void NetworkProcess(ConsoleEvent e)
	{
		if (HeldDownTics <= 0) mouseclicked = false;
		if (e.Name ~== "releasemouse")
		{
			self.MouseHeldDown = false;
			self.MouseClicked = false;
			//HeldDownTics = 0;
		}
		if (e.Name ~== "openmonstermenu")
		{
			MonsterMenuOpened = true;
			NonMainMenu = true;
			S_Sound("PDAOPEN",CHAN_AUTO);
		}
		if (e.Name ~== "closemonstermenu")
		{
			MonsterMenuOpened = false;
			WeaponMenuOpened = false;
			NonMainMenu = false;
			S_Sound("PDABACK",CHAN_AUTO);
		}
		if (e.Name ~== "openweaponmenu")
		{
			WeaponMenuOpened = true;
			NonMainMenu = true;
			S_Sound("PDAOPEN",CHAN_AUTO);
		}
		if (MouseHeldDown == false && MouseClicked == true && !(HeldDownTics <= 0) ) HeldDownTics--;
		if (e.Name ~== "input")
		{
			if (e.Args[2] == 1)
			{
				//Console.Printf("Mouse Event Detected");
				if (MouseClicked == true && !MouseHeldDown)
				{
					MouseHeldDown = true;
					HeldDownTics++;
				}
				else
				{
					MouseClicked = true;
					MouseHeldDown = true;
					if (HeldDownTics < 2) HeldDownTics++;
				}
			}
			else if (e.Args[2] == 2)
			{
				if (HeldDownTics <= 0) mouseclicked = false;
				MouseHeldDown = false;
			}
			if (players[e.Player].cmd.buttons & BT_USER1)
			{
				SetPlayerProperty(1,1,4);
				int freezemask = 1 << e.Player;
				players[e.Player].timefreezer |= freezemask;
				Level.SetFrozen(true);
				S_Sound("PDAOPEN",CHAN_AUTO);
				PDAMode = true;
			}
			if (PDAMode == true && MousePositionSet == true)
			{
				DeltaMouseX = e.Args[0] / 2;
				DeltaMouseY = e.Args[1];
				MouseX += DeltaMouseX;
				MouseY -= DeltaMouseY;
			}
		}
		if (e.Name ~== "exitpda")
		{
			SetPlayerProperty(1,0,4);
			players[consoleplayer].timefreezer &= ~(1 << consoleplayer);
			Level.SetFrozen(false);
			S_Sound("PDABACK",CHAN_AUTO);
			PDAMode = false;
			MouseX = 1;
			MouseY = 1;
			MousePositionSet = false;
			MouseClicked = false;
			MonsterMenuOpened = false;
			WeaponMenuOpened = False;
			NonMainMenu = false;
		}
		if (e.Name ~== "modifymousepos")
		{
			MouseX = e.Args[0];
			MouseY = e.Args[1];
			MousePositionSet = true;
		}
		Array<String> splittedStrings;
		e.Name.Split(splittedStrings,":");
		if (SplittedStrings.Size() == 0) return;
		if (splittedStrings[0] == "addweaponclass")
		{
			PBWeapons.Push(splittedStrings[1]);
		}
	}
	override void WorldLoaded(WorldEvent e)
	{
		if (e.IsSaveGame)
		{
			ClearArrays = true;
			PDAMonsterStrings.Clear();
			PDAWeaponStrings.Clear();
		}
	}
	override void OnRegister()
	{
		MouseX = 1;
		MouseY = 1;
		PDAMode = false;
	}
	clearscope Vector2 GetTextureCenterPosition(TextureID tex)
	{
		if (!tex) return (0,0);
		return TexMan.GetScaledSize(tex) / 2;
	}
	override void RenderOverlay(RenderEvent e)
	{
		if (MouseX == 1 && MouseY == 1 && !MousePositionSet)
		{
			SendNetworkEvent("modifymousepos",Screen.GetWidth() / 2,Screen.GetHeight() / 2);
		}
		if (ClearArrays == true)
		{
			// Destruct all arrays.
			PDAWeaponHeaders.Clear();
			PDAWeaponTexts.Clear();
			PDAWeaponTextVSize.Clear();
			PDAWeaponTextHSize.Clear();
			UiObjects.Clear();
			DescriptionDialog.Destroy();
			DescriptionDialog = null;
		}
		if (PDAMode == true)
		{
			TextureID cursortex = Texman.CheckForTexture("ZCURSOR",TexMan.Type_Any);
			Screen.Dim("Black",0.50,0,0,Screen.GetWidth(),Screen.GetHeight());
			for (int ii = 0; ii < Screen.GetHeight(); ii += Screen.GetHeight() / 20)
			{
				Screen.DrawLine(0,ii,Screen.GetWidth(),ii,"Cyan",255/2);
			}
			for (int iii = 0; iii < Screen.GetWidth(); iii += Screen.GetWidth() / 20)
			{
				Screen.DrawLine(iii,0,iii,Screen.GetHeight(),"Cyan",255/2);
			}
			if (UiObjects.Size() >= 1)
			{
				for (int i = 0; i < UiObjects.Size(); i++)
				{
					if (UiObjects[i].objecttype == 1 && (MonsterMenuOpened || WeaponMenuOpened))
					{
						UiObjects[i].notdrawn = true;
						continue;
					}
					if (uiObjects[i].objecttype == 2 && (WeaponMenuOpened || MonsterMenuOpened))
					{
						UiObjects[i].notdrawn = true;
						continue;
					}
					if (uiObjects[i].NonMainMenuOnly && !NonMainMenu)
					{
						UiObjects[i].notdrawn = true;
						continue;
					}
					if (uiObjects[i].MonsterMenuOnly == true && MonsterMenuOpened == false)
					{
						UiObjects[i].notdrawn = true;
						continue;
					}
					if (uiObjects[i].WeaponMenuOnly == true && WeaponMenuOpened == false)
					{
						uiObjects[i].notdrawn = true;
						continue;
					}
					if (uiObjects[i].NonMainMenuOnly == true && !NonMainMenu)
					{
						uiObjects[i].notdrawn = true;
						continue;
					}
					if (UiObjects[i].todraw)
					{
						Screen.DrawText(UiObjects[i].usefont,UiObjects[i].fontcolor,UiObjects[i].ImagePos.x,UiObjects[i].ImagePos.y,UiObjects[i].toDraw,DTA_CleanNoMove_1,true);
						uiObjects[i].notdrawn = false;
					}
					else if (UiObjects[i].DialogPicture)
					{
						Screen.DrawTexture(UiObjects[i].DialogPicture,false,UiObjects[i].ImagePos.x,UiObjects[i].ImagePos.y);
						UiObjects[i].notdrawn = false;
					}
					else UiObjects[i].notdrawn = true;
				}
			}
			//if (MonsterMenuButton != null && !MonsterMenuOpened) Screen.DrawText(MonsterMenuButton.usefont,MonsterMenuButton.fontcolor,MonsterMenuButton.ImagePos.x,MonsterMenuButton.ImagePos.y,MonsterMenuButton.toDraw,DTA_CleanNoMove_1,true);
			if (descriptiondialog != null && NonMainMenu == true) Screen.DrawText(descriptiondialog.usefont,Font.CR_UNTRANSLATED,descriptiondialog.ImagePos.x,descriptiondialog.ImagePos.y,descriptiondialog.todraw,DTA_CleanNoMove_1,true,DTA_ClipTop,descriptiondialog.descClipY,DTA_ClipBottom,descriptiondialog.descClipH);
			//Screen.DrawShape(TexMan.CheckForTexture("BLOOD1",TexMan.Type_Any),false,UpArrow);
			Screen.DrawTexture(cursortex,false,MouseX,MouseY);
			//Screen.DrawText(SmallFont,Font.CR_YELLOW,MouseX+12,MouseY+12,""..MouseX.."/"..MouseY);
			if (UiObjects.Size() >= 1) return;
			//Initialize the objects.
			
			int lump = Wads.FindLump("PDAMONST");
			string stuff = Wads.ReadLump(lump);
			stuff.Split(PDAMonsterStrings,",");
			int weaplump = Wads.FindLump("PDAWEAP");
			string weapstuff = Wads.ReadLump(weaplump);
			weapstuff.Split(PDAWeaponStrings,",");
			int weaptlump = Wads.FindLump("PDAWEAPT");
			string weaptstuff = Wads.ReadLump(weaptlump);
			Array<String> weaptstrings;
			Array<String> initialweaptstrings;
			weaptstuff.Split(initialweaptstrings,"#");
			for (int splitCounter = 0; splitcounter < initialweaptstrings.Size(); splitcounter++)
			{
				initialweaptstrings[splitCounter].Split(weaptstrings,"$");
			}
			int forcounter = 1;
			int iii = 0;
			for (iii = 0; iii < weaptstrings.Size(); ++iii)
			{
				if (forcounter == 3)
				{
					SendNetworkEvent("addweaponclass:"..weaptstrings[iii]);
					forcounter = 0;
				}
				else if (forcounter == 2)
				{
					PDAWeaponTexts.Push(weaptstrings[iii]);
				}
				else if (forcounter == 1) PDAWeaponHeaders.Push(weaptstrings[iii]);
				++forcounter;
			}
			BrokenLines WeaponTextLines;
			string NewWeaponText;
			font breaklinefont = SmallFont;
			int largestStringWidth = 0;
			
			for (iii = 0; iii < PDAWeaponTexts.Size(); iii++)
			{
				NewWeaponText = "";
				WeaponTextLines = breaklinefont.BreakLines(PDAWeaponTexts[iii],200);
				for (int linecounter = 0; linecounter < WeaponTextLines.Count(); ++linecounter)
				{
					string linestring = WeaponTextLines.StringAt(lineCounter);
					if (LargestStringWidth < SmallFont.StringWidth(WeaponTextLines.StringAt(lineCounter))*CleanYFac) largestStringWidth = WeaponTextLines.StringWidth(linecounter) * CleanXFac;
					linestring.AppendCharacter(10);
					NewWeaponText = NewWeaponText..Linestring;
				}
				PDAWeaponTexts[iii] = NewWeaponText;
				PDAWeaponTextVSize.Push(breaklinefont.GetHeight() * CleanYFac_1 * WeaponTextLines.Count());
				PDAWeaponTextHSize.Push(largestStringWidth * CleanXFac_1);
			}
			let descdialog = new("PB_PDAUi_Object");
			descdialog.todraw = "Select a entry to \nview its description";
			descdialog.UnSelectable = true;
			descdialog.InitializeUiObject();
			descdialog.ImagePos = (Screen.GetWidth() / 2,Screen.GetHeight() / 10);
			descdialog.InitialImagePos = descdialog.ImagePos;
			descdialog.descClipY = descdialog.ImagePos.Y;
			descdialog.descClipH = descdialog.ImagePos.Y + 240;
			descriptiondialog = descdialog;
			UpArrowPos = (LargestStringWidth + DescriptionDialog.ImagePos.X,descdialog.ImagePos.Y);
			DownArrowPos = (UpArrowPos.x,descdialog.descClipH);
			let UpArrowDialog = new("PB_PDAUi_Object");
			UpArrowDialog.Objecttype = 4;
			UpArrowDialog.ImagePos = UpArrowPos;
			UpArrowDialog.todraw = "\x1a";
			UpArrowDialog.NonMainMenuOnly = true;
			UpArrowDialog.InitializeUiObject(confont);
			UiObjects.Push(UpArrowDialog);
			PB_PDAUi_Object DownArrowDialog = new("PB_PDAUi_Object");
			DownArrowDialog.ImagePos = DownArrowPos;
			DownArrowDialog.todraw = "\x1b";
			DownArrowDialog.ObjectType = 5;
			DownArrowDialog.NonMainMenuOnly = true;
			DownArrowDialog.InitializeUiObject(confont);
			UiObjects.Push(DownArrowDialog);
			Vector2 monstertextpos = (Screen.GetWidth() / 5,Screen.GetHeight() / 5);
			for (int ii = 0; ii < PDAWeaponStrings.Size(); ++ii)
			{
				let weapontext = new("PB_PDAUi_Object");
				weapontext.entrynumber = ii;
				weapontext.WeaponMenuOnly = true;
				weapontext.toDraw = PDAWeaponStrings[ii];
				weapontext.ImagePos.y = (MonsterTextPos.y * 0.25) * (ii);
				weapontext.InitializeUiObject();
				weapontext.objecttype = 3;
				UiObjects.Push(weapontext);
			}
			for (int i = 0; i < PDAMonsterStrings.Size(); ++i)
			{
				let monstertext = new("PB_PDAUi_Object");
				monstertext.MonsterMenuOnly = true;
				monstertext.toDraw = PDAMonsterStrings[i];
				monstertext.ImagePos.y = (monstertextpos.y * 0.25) * (i);
				monstertext.InitializeUiObject();
				UiObjects.Push(monstertext);
			}
			let BackDialog = new("PB_PDAUi_Object");
			BackDialog.todraw = "Back";
			BackDialog.InitializeUiObject();
			BackDialog.BackButtonTrue = true;
			BackDialog.NonMainMenuOnly = true;
			BackDialog.ImagePos = (0,Screen.GetHeight() - BackDialog.ImageSize.y);
			uiObjects.Push(BackDialog);
			let dialog = new("PB_PDAUi_Object");
			dialog.toDraw = "Exit";
			dialog.InitializeUiObject();
			dialog.exitbuttontrue = True;
			let monsterdialog = new("PB_PDAUi_Object");
			monsterdialog.objecttype = 1;
			monsterdialog.toDraw = monsterDialog.GetString();
			monsterdialog.InitializeUiObject();
			monsterdialog.ImagePos = (Screen.GetWidth() / 4, Screen.GetHeight() / 2);
			uiObjects.Push(monsterdialog);
			let weapondialog = new("PB_PDAUi_Object");
			weapondialog.objecttype = 2;
			weapondialog.toDraw = "Weapons";
			weapondialog.InitializeUiObject();
			weapondialog.ImagePos = (MonsterDialog.ImagePos.x,MonsterDialog.ImagePos.y + MonsterDialog.ImageSize.y);
			uiObjects.Push(weapondialog);
			//self.MonsterMenuButton = monsterDialog;
			dialog.ImagePos = ((Screen.GetWidth() ) - Screen.GetWidth()/4, (Screen.GetHeight() ) - Screen.GetHeight()/4);
			UiObjects.Push(dialog);
		}
	}
	override bool InputProcess(InputEvent e)
	{
		int mouseinput = 0;
		if (e.KeyScan == InputEvent.Key_Mouse1 && e.Type == InputEvent.Type_KeyDown) mouseinput = 1;
		if (e.KeyScan == InputEvent.Key_Mouse1 && e.Type == InputEvent.Type_KeyUp) mouseinput = 2;
		SendNetworkEvent("input",e.mouseX, e.mouseY,int(mouseinput));
		return false;
	}
}
class DoNotDoubleJump : Inventory {}
class BossBrainBase : Actor
{
	void RemoveCubes()
	{
		ThinkerIterator ti = ThinkerIterator.Create("Actor");
		Actor a;
		while (a = Actor(ti.Next()))
		{
			if (a is "SpawnShot" || a is "BossEye") a.Destroy();
			if (a.bISMONSTER && a.bCOUNTKILL) a.A_Die("Massacre");
		}
	}
}

class HeadShotBaseZScript : Actor //ZScriptified Headbox
{
	Default
	{
		damagefactor "Taunt", 0.0;
		damagefactor "Blood", 0.0;
		damagefactor "BlueBlood", 0.0;
		damagefactor "Head", 0.0;
		damagefactor "MinorHead", 0.0;
		damagefactor "KillMe", 0.0;
		damagefactor "Control", 0.0;
		damagefactor "Trample", 0.0;
		damagefactor "GibRemoving", 0.0;
		//damagefactor "Melee", 0.3
		damagefactor "Alert", 0.0;
		damagefactor "SSG", 8.0;
		damagefactor "ExplosiveImpact", 0.0;
		damagefactor "Bullet", 1.5;
		damagefactor "GibRemoving", 0.0;
		damagefactor "TeleportRemover", 0.0;
		DamageFactor "Freeze", 0.0;
		DamageFactor "Shrink", 0.0;
		DamageFactor "Frost", 0.0;
		DamageFactor "Ice", 0.0;
		DamageFactor "Blackhole", 0.0;
		Speed 0;
		Radius 7;
		Height 18;
		BloodType "Brutal_Blood", "SawBlood", "SawBlood";
		-COUNTKILL +NOTARGET +MISSILE
		+NOGRAVITY +SHOOTABLE +NOTELEPORT -SOLID +NODAMAGETHRUST
		+THRUGHOST +NORADIUSDMG +GHOST -COUNTKILL +NOTAUTOAIMED +DONTTHRUST
	}
	States
	{
		Spawn:
			TNT1 A 1;
			Loop;
	}
	override void Tick()
	{
		Super.Tick();
		Console.Printf("1");
		if (master) SetOrigin(master.pos + (0,0,master.height - (master.height / 6)),true);
	}
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		//A_GiveInventory("RadiusDebugMe");
		if (target) 
		{
			master = target;
			
			bMISSILE = false;
		}
	}
	override int DamageMobj(Actor inflictor, Actor source,int damage,Name mod,int Flags,Double angle)
	{
		Console.Printf("Got Hit");
		if (master) master.DamageMobj(inflictor,source,damage * 1.5,mod == 'None' ? 'Head' : mod, flags,angle);
		return 0; //Do no real damage to self
	}
}
class HeadshotBaseZScriptB :HeadshotBaseZScript //Green blood headbox
{
	Default
	{
		BloodType "Green_Blood", "GreenSawBlood", "GreenSawBlood";
		BloodColor "DarkGreen";
		Radius 12;
		Height 22;
		+NOBLOODDECALS
	}
}
class SpawnerBase : Actor
{
	void SpawnActor(class<Actor> spawnactor, bool HandleSpawnFlags = true)
	{
			Actor a = self;
			Actor r = a.Spawn(spawnactor,a.pos);
			r.spawnangle = a.spawnangle;
			r.angle = a.angle;
			r.pitch = a.pitch;
			r.roll = a.roll;
			r.spawnpoint = a.spawnpoint;
			r.special = a.special;
			r.args[0] = a.args[0];
			r.args[1] = a.args[1];
			r.args[2] = a.args[2];
			r.args[3] = a.args[3];
			r.args[4] = a.args[4];
			r.special1 = a.special1;
			r.special2 = a.special2;
			r.spawnflags = a.spawnflags&~MTF_SECRET;
			if (HandleSpawnFlags) r.HandleSpawnFlags();
			r.spawnflags = a.spawnflags;
			r.bCOUNTSECRET = a.spawnflags&MTF_SECRET;
			r.ChangeTid(a.tid);
			r.Vel = a.vel;
	}
}
enum EPBWeaponFlags
{
	PBWEAP_KEEPYOFFSET = 1<<0, //Weapon must not move up/down when looking up/down.
	PBWEAP_ISPISTOLSILENCERSTATE = 1<<3, // Weapon is equipped with a silencer.
	PBWEAP_UNLOADED = 1<<4 // Weapon has been unloaded.
}
class InvisiblePuff : BulletPuff
{
	Default
	{
		-ALLOWPARTICLES
	}
}
class InvisiblePuffAlways : InvisiblePuff
{
	Default
	{
		+ALWAYSPUFF
		+THRUACTORS
		+ALLOWTHRUFLAGS
	}
}
class CameraRunner : Inventory
{
	static bool CheckForCamera(class<Actor> classname,int tidnum)
	{
		ActorIterator at = ActorIterator.Create(tidnum);
		Actor a = at.Next();
		if (a != NULL && a.GetClassName() == classname) return true;
		return false;
	}
	static Actor CheckForCameraActor(class<Actor> classname,int tidnum)
	{
		ActorIterator at = ActorIterator.Create(tidnum);
		Actor a = at.Next();
		if (a != NULL && a.GetClassName() == classname) return a;
		return null;
	}
	static void SetActorAngle(int tidnum, double angle)
	{
		ActorIterator at = ActorIterator.Create(tidnum);
		Actor a = at.Next();
		if (a != NULL) a.angle = angle;
	}
	static void SetActorPitch(int tidnum, double pitch)
	{
		ActorIterator at = ActorIterator.Create(tidnum);
		Actor a = at.Next();
		if (a != NULL) a.pitch = pitch;
	}
	static void SetActorRoll(int tidnum, double roll)
	{
		ActorIterator at = ActorIterator.Create(tidnum);
		Actor a = at.Next();
		if (a != NULL) a.roll = roll;
	}
	static bool, Actor ExtSpawn(class<Actor> classname,Vector3 pos,int tid,double angle)
	{
		Actor a = Spawn(classname,pos,ALLOW_REPLACE);
		if (a != NULL)
		{
			a.ChangeTid(tid);
			a.angle = angle;
			return true, a;
		}
		return false, null;
	}
	static bool SetActorPosition(int tidnum, Vector3 pos)
	{
		Actor a = CheckForCameraActor("ChaseCam2",tidnum);
		if (a != NULL)
		{
			a.SetOrigin(pos,true);
			if (a.pos == pos) return true;
		}
		return false;
	}
	void TerminateCamera()
	{
		owner.SetCamera(null);
		Actor a = CheckForCameraActor("ChaseCam2",C_TID + PlayerPawn(owner).PlayerNumber());
		if (a != NULL) a.Destroy();
	}
	static void WarpCamera(int tid, int plrnum = 1)
	{
		ActorIterator ai = ActorIterator.Create(tid);
		Actor a = ai.Next();
		if (a != NULL)
		{
			actor cameraactor;
			if ((cameraactor = ActorIterator.Create(6400 + plrnum,"WarpCamera").Next()) != NULL)
			{
				Players[plrnum].mo.SetCamera(cameraactor);
				cameraactor.Warp(a,flags: WARPF_INTERPOLATE | WARPF_COPYPITCH);
				cameraactor.SetOrigin(Players[plrnum].mo.vel + cameraactor.pos,true);
			}
		}
		else
		{
			players[consoleplayer].mo.SetCamera(null);
		}
	}
	Vector3, double, double, actor ReturnCamPos(Actor a)
	{
		Actor linepuff = a.LineAttack(a.angle - 180,128 + (a.radius*2),-a.pitch,0,'None',"InvisiblePuffAlways",LAF_NOINTERACT|LAF_NORANDOMPUFFZ,null,-(a.height/2) + a.player.viewheight);
		if (linepuff)
		{
			let vec3 = linepuff.pos + a.vel;
			let anglevalue = linepuff.angle;
			let pitchvalue = linepuff.pitch;
			linepuff.bINVISIBLE = true;
			//linepuff.Destroy();
			return vec3, anglevalue, pitchvalue,linepuff;
		}
		return a.pos, a.angle, a.pitch, null;
	}
	//ACS Prefab chasecam script ported to ZScript with changes by Cacodemon345.
	void RunCameraNew()
	{
		if (!owner.player || !owner) return; //Don't start camera if the owner isn't a player or is null.
		Double anglevalue;
		Double pitchvalue;
		Double actualpitch = owner.pitch;
		actor linepuff;
		Vector3 campos;
		int plrnum = PlayerPawn(owner).PlayerNumber();
		[campos,anglevalue, pitchvalue,linepuff] = ReturnCamPos(owner);
		if (!CheckForCamera("ChaseCam2",C_TID + plrnum))
		{
			Actor cameraactor;
			bool cameraspawned;
			[cameraspawned, cameraactor] = self.ExtSpawn ("ChaseCam2", campos, C_TID+plrnum, angle);
			if (CheckForCamera ("ChaseCam2", C_TID + plrnum))
			owner.SetCamera(cameraactor);
			else
			{
				Console.MidPrint ("INDEXFONT_DOOM","Camera script failed to initialize.");
				return;
			}
		}
		else
		{
			Actor cameraactor = CheckForCameraActor("ChaseCam2",C_TID + plrnum);
			cameraactor.SetOrigin(campos,true);
			//cameraactor.Warp(owner,0,0,0,0,WARPF_INTERPOLATE);
			self.SetActorAngle (C_TID + plrnum, anglevalue);
			self.SetActorPitch (C_TID + plrnum, actualpitch);
			self.SetActorRoll  (C_TID + plrnum, owner.roll);
		}
	}
	override void DoEffect()
	{
		let p = PlayerPawn(owner);
		if (p)
		{
			self.RunCameraNew();
		}
	}
	override void OnDestroy()
	{
		let p = PlayerPawn(owner);
		if (p)
		{
			self.TerminateCamera();
		}
		Super.OnDestroy();
	}
}
class TankBaseNotReal : Actor
{
	Actor warpto;
	int spritestate;
	Default
	{
		+THRUACTORS
		YScale 1.8;
		XScale 1.9;
		+NOTIMEFREEZE
		+NOBLOOD
		+NOBLOODDECALS
		+CLIENTSIDEONLY
		+FLOORCLIP
		+NOGRAVITY
		+FLOAT
		+NOBLOCKMAP
		+THRUSPECIES
		+MTHRUSPECIES
		Species "TankProj";
		Mass 99999;
		Radius 0;
		Height 0;
		Gravity 0;
	}
	States
	{
		Spawn:
			TNT1 A 0;
			TNK1 B 1
			{
				switch(spritestate)
				{
					default:
						break;
					case 1:
						self.SetStateLabel("Spawn1");
						break;
					case 2:
						self.SetStateLabel("Spawn2");
						break;
					case 3:
						self.SetStateLabel("Spawn3");
						break;
				}
			}
			TNT1 A 0 A_SPawnItemEx("TankWeakSpotBase", -65, 0, 2);
			Loop;
		Spawn1:
			TNT1 A 0;
			TNT1 A 0 A_Stop;
			TNT1 A 0 A_SPawnItemEx("TankWeakSpotBase", -65, 0, 2);
			TNK1 B 1;
			Goto Spawn;
		Spawn2:
			TNT1 A 0 A_SPawnItemEx("TankWeakSpotBase", -75, 0, 2);
			TNK1 D 1;
			Goto Spawn;
		Spawn3:
			TNT1 A 0 A_SPawnItemEx("TankWeakSpotBase", -75, 0, 2);
			TNK1 E 1;
			Goto Spawn;
	}
}


class LaserDeactivated : Inventory {}
class FlyingGibBase : Actor
{
	override void Tick()
	{
		Super.Tick();
		//Spawn("Brutal_LiquidBlood3",pos);
	}
}
class XDeathGibBase : Actor
{
	void A_PBGibMissile(class<Actor> missiletype, double spawnheight = 32, double spawnofs_xy = 0, double angle = 0, int flags = 0, double pitch = 0, int ptr = AAPTR_TARGET)
	{
		let a = A_SpawnProjectile(missiletype, spawnheight, spawnofs_xy, angle, flags | CMF_BADPITCH | CMF_SAVEPITCH, pitch, ptr);
		if (a)
		{
			a.VelFromAngle(vel.xy.Length() / 2, self.angle + frandom(-20, 20));
			a.vel.z += vel.z + 5;
		}
	}
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		if (target)
		{
			vel = target.vel;
			A_FaceMovementDirection();
		}
	}
}
class PB_WeaponBase : DoomWeapon 
{
	Actor laseractor;
	Actor InvActor;
	Vector3 invactorpos;
	Statelabel UnloadedState;
	property UnloadedState: UnloadedState;
	string UnloaderToken;
	property UnloaderToken: UnloaderToken;
	int integer;
	string MidWeaponPickupMessage;
	property MidPickupMessage: MidWeaponPickupMessage;
	Default
	{
		PB_WeaponBase.UnloaderToken "HasUnloaded";
	}
	action void A_DecideSpawnLaserPuff()
	{
			if (CountInv("LaserSightActivated")==1 && CountInv("KeepLaserDeactivated") != 1)
			{
				invoker.A_SpawnLaserPuff();
			}
			else 
			{
				invoker.A_DestroyLaserPuff();
			}
	}
	action void A_DestroyLaserPuff()
	{
		if (invoker.laseractor) invoker.laseractor.Destroy();
	}
	action Actor A_SpawnLaserPuff()
	{
		int integer;
		[invoker.InvActor, invoker.integer] = LineAttack(angle,4096,pitch,0,'None',"InvisiblePuff",LAF_NORANDOMPUFFZ|LAF_NOINTERACT);
		if (invoker.InvActor)
		{
			invoker.invactorpos = invoker.InvActor.pos;
			invoker.InvActor.Destroy();
		}
		if (!invoker.laseractor) invoker.laseractor = Spawn("LaserDotPerma",invoker.invactorpos);
		else invoker.laseractor.SetOrigin(invoker.invactorpos, true);
		
		return invoker.laseractor;
	}
	action int CheckUnloaded(string token)
	{
		if (CountInv(token) == 1) return PBWEAP_UNLOADED;
		return 0;
	}
	action state A_DoPBWeaponAction(int weapflags = WRF_ALLOWRELOAD, int pbFlags = 0, string unloadtoken = "HasUnloaded")
	{
		static const string PBWeapEmptyToken[] = 
		{
			"PBPistolWasEmpty","RifleWasEmpty","UACSMGWasEmpty"
		};
		static const string PBWeapUnloadedToken[] =
		{
			"HasUnloaded","PulseCannonHasUnloaded", "HasUnloadedRG"
		};
		static const string PBWeapUnloadableClasses [] =
		{
			"PB_Weapon","PulseCannon"
		};
		static const statelabel PBWeapStatelabels[] =
		{
			"Steady", "LedgeClimb", "QuickPunch",
			"DoKick", "Taunt", "Salute", "Salute",
			"UseEquipment", "SwitchEquipment", "DualWieldBaby",
			"NoDualWield", "WeaponSpecial", "GrabbedBarrel", "GrabbedBurningBarrel"
		};
		if (!(pbFlags & PBWEAP_UNLOADED)) pbFlags |= CheckUnloaded(invoker.UnloaderToken);
		if (CountInv("GoFatality")>=1)
		{
			return ResolveState("Steady");
		}
		else if (CountInv("Grabbing_A_Ledge")>=1) 
		{
			return ResolveState("LedgeClimb");
		}
		else if (CountInv("DoPunch")>=1) 
		{
			return ResolveState("QuickPunch");
		}
		else if (CountInv("Kicking")>=1) 
		{
			return ResolveState("DoKick");
		}
		else if (CountInv("Taunting")>=1) 
		{
			return ResolveState("Taunt");
		}
		else if (CountInv("Salute1")>=1 || CountInv("Salute2")>=1) 
		{
			return ResolveState("Salute");
		}
		else if (CountInv("UseEquipment")>=1) 
		{
			return ResolveState("UseEquipment");
		}
		else if (CountInv("ToggleEquipment")>=1) 
		{
			return ResolveState("SwitchEquipment");
		}
		else if (CountInv("GoWeaponSpecialAbility")>=1)
		{
			if (ResolveState("DualWieldBaby")) return ResolveState("DualWieldBaby");
			else if (ResolveState("NoDualWield")) return ResolveState("NoDualWield");
			else return ResolveState("WeaponSpecial");
		}
		else if (CountInv("GrabbedBarrel")>=1 || CountInv("GrabbedBurningBarrel")>=1) 
		{
			return ResolveState("GrabBarrel");
		}
		else if (CountInv("Unloading")>=1 && ResolveState("Unload") && !(pbFlags & PBWEAP_UNLOADED) && CountInv(invoker.UnloaderToken) != 1)
		{
			return ResolveState("Unload");
		}
		else if (CountInv(invoker.UnloaderToken) >= 1 && !(pbFlags & PBWEAP_UNLOADED) && !InStateSequence(invoker.owner.player.GetPSprite(PSP_WEAPON).Curstate,invoker.ResolveState("GunEmpty")))
		{
			return ResolveState("GunEmpty");
		}
		else if (ResolveState("LoadChamber"))
		{
			for (int i = 0; i < PBWeapEmptyToken.Size(); ++i)
			{
				if (CountInv(PBWeapEmptyToken[i]) >= 1)
				{
					return ResolveState("LoadChamber");
				}
			}
		}
		else if (ResolveState("ReadyToFireSilencer") 
		&& CountInv("SilencerEquipped") >= 1
		&& !(pbFlags & PBWEAP_ISPISTOLSILENCERSTATE))
		{
			return ResolveState("ReadyToFireSilencer");
		}
		A_WeaponReady(weapflags);
		A_WeaponOffset(-CallACS("Script_GetGunOffsetX"), CallACS("Script_GetGunOffsetY")-1,WOF_INTERPOLATE | (!!(pbFlags & PBWEAP_KEEPYOFFSET) ? WOF_KEEPY : 0));
		return null;
	}
  
	action void A_SetWeaponSprite(String str)
        {
                    let psp = player.GetPSprite(PSP_WEAPON);
                    psp.sprite = GetSpriteIndex(str);
        }
}

// Optional Motion Blur by Pixel Eater
class MBlurHandler : StaticEventHandler
{
	int			pitch, yaw ;
	double		xtravel, ytravel ;
	
	override void PlayerEntered( PlayerEvent e )
	{
		PlayerInfo plr = players[ consoleplayer ];
		if( plr )
		{	
			xtravel = 0 ;
			ytravel = 0 ;
		}
	}
	
	override void WorldTick()
	{
		PlayerInfo	plr = players[ consoleplayer ];
		if( plr && plr.health > 0 && Cvar.GetCVar( "mblur", plr ).GetBool() )
		{
			yaw		= plr.mo.GetPlayerInput( ModInput_Yaw );
			pitch	= -plr.mo.GetPlayerInput( ModInput_Pitch );
		}
	}
	
	override void NetworkProcess( ConsoleEvent e )
	{
		PlayerInfo	plr = players[ consoleplayer ];
		if( plr && e.Name == "liveupdate" )
		{
			double pitchdimin	= 1. - abs( plr.mo.pitch * 1. / 90 );
			double decay		= 1. - Cvar.GetCVar( "mblur_recovery", plr ).GetFloat() * .01 ;
			double amount		= Cvar.GetCVar( "mblur_strength", plr ).GetFloat() * 10. / 32767 * sqrt( pitchdimin );
			xtravel				= xtravel * decay + yaw * amount * .625 ;
			ytravel				= ytravel * decay + pitch * amount ;
			
			if( Cvar.GetCVar( "mblur_autostop", plr ).GetBool() )
			{
				double threshold = Cvar.GetCVar( "mblur_threshold", plr ).GetFloat() * 30 ;
				double recovery2 = 1 - Cvar.GetCVar( "mblur_recovery2", plr ).GetFloat() * .01 ;
				if( abs( yaw )		<= threshold ) xtravel *= recovery2 ;
				if( abs( pitch )	<= threshold ) ytravel *= recovery2 ;
			}
		}
	}
	
	override void UiTick()
	{
		PlayerInfo	plr = players[ consoleplayer ];
		if( plr )
		{
			if( plr.health > 0 && Cvar.GetCVar( "mblur", plr ).GetBool() )//&& yaw && pitch )
			{
				EventHandler.SendNetworkEvent( "liveupdate" );
				
				int copies			= 1 + Cvar.GetCVar( "mblur_samples", plr ).GetInt() ;
				double increment	= 1. / copies ;
				vector2 travel		= ( xtravel, ytravel ) / screen.getheight() ;
				
				Shader.SetUniform2f( plr, "MBlur", "steps", travel * increment );
				Shader.SetUniform1f( plr, "MBlur", "samples", copies );
				Shader.SetUniform1f( plr, "MBlur", "increment", increment );
				Shader.SetUniform1f( plr, "MBlur", "blendmode", Cvar.GetCVar( "mblur_blendmode", plr ).GetInt() );
					
				Shader.SetEnabled( plr, "MBlur", true );
			}
			else
			{
				Shader.SetEnabled( plr, "MBlur", false );
			}
		}
	}
}
